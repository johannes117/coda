import { promises as fs } from 'fs';
import path from 'path';

const IGNORED_DIRS = new Set(['node_modules', '.git', 'dist']);
const MAX_BYTES_PER_FILE = 1024 * 1024; // 1 MB hard cap per file shard

async function* walk(dir: string): AsyncGenerator<string> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (!IGNORED_DIRS.has(entry.name)) yield* walk(full);
    } else {
      yield full;
    }
  }
}

function looksBinary(buf: Buffer): boolean {
  // super lightweight heuristic: NUL or >30% non-ASCII
  const len = Math.min(buf.length, 4096);
  let nonAscii = 0;
  for (let i = 0; i < len; i++) {
    const b = buf[i];
    if (b === 0) return true;
    if (b < 9 || (b > 13 && b < 32) || b > 126) nonAscii++;
  }
  return nonAscii / Math.max(1, len) > 0.3;
}

export type ResolvedContextFile = { abs: string; rel: string };

export async function resolveContextPaths(
  selections: string[],
  rootDir = process.cwd()
): Promise<ResolvedContextFile[]> {
  const out: ResolvedContextFile[] = [];
  const seen = new Set<string>();
  for (const sel of selections) {
    const abs = path.resolve(rootDir, sel);
    let stat: any;
    try {
      stat = await fs.stat(abs);
    } catch {
      continue;
    }
    if (stat.isDirectory()) {
      for await (const f of walk(abs)) {
        const rel = path.relative(rootDir, f);
        if (!seen.has(rel)) {
          seen.add(rel);
          out.push({ abs: f, rel });
        }
      }
    } else if (stat.isFile()) {
      const rel = path.relative(rootDir, abs);
      if (!seen.has(rel)) {
        seen.add(rel);
        out.push({ abs, rel });
      }
    }
  }
  // stable order for determinism
  out.sort((a, b) => a.rel.localeCompare(b.rel));
  return out;
}

export async function buildFileContextBlob(
  selections: string[],
  rootDir = process.cwd()
): Promise<string | null> {
  if (!selections.length) return null;
  const files = await resolveContextPaths(selections, rootDir);
  if (files.length === 0) return null;

  const parts: string[] = [];
  parts.push('## FILE CONTEXT (auto-generated by coda)');
  parts.push('');
  parts.push(`Included items: ${selections.join(', ')}`);
  parts.push('');

  for (const f of files) {
    try {
      const stat = await fs.stat(f.abs);
      if (stat.size > MAX_BYTES_PER_FILE) {
        parts.push(`### ${f.rel}`);
        parts.push('```text');
        parts.push(`(skipped: file too large at ${stat.size} bytes)`);
        parts.push('```');
        parts.push('');
        continue;
      }
      const buf = await fs.readFile(f.abs);
      if (looksBinary(buf)) {
        parts.push(`### ${f.rel}`);
        parts.push('```text');
        parts.push('(skipped: binary file)');
        parts.push('```');
        parts.push('');
        continue;
      }
      const content = buf.toString('utf8');
      parts.push(`### ${f.rel}`);
      parts.push('```');
      parts.push(content);
      parts.push('```');
      parts.push('');
    } catch {
      // ignore individual file read errors
    }
  }

  return parts.join('\n');
}
